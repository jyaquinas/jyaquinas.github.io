I"nå<h3 id="select">SELECT</h3>

<p>Let‚Äôs say this is our table.</p>

<table>
  <thead>
    <tr>
      <th>CUSTOMERS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CUSTOMER_ID<br />FIRST_NAME<br />LAST_NAME<br />BIRTHDAY<br />ADDRESS<br />AGE</td>
    </tr>
  </tbody>
</table>

<p>The basic format is:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">exp</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="p">[</span><span class="k">WHERE</span> <span class="n">condition</span><span class="p">];</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">exp</code>: use * for selecting all columns, or list the specific columns you want<br />
<code class="language-plaintext highlighter-rouge">table_name</code>: at least one table required<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><br />
<code class="language-plaintext highlighter-rouge">condition</code>: returns all rows if no condition is used</p>

<p>ex)</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">;</span>
</code></pre></div></div>

<p>If you want to return only distinct values, you can use <code class="language-plaintext highlighter-rouge">SELECT DISTINCT</code> instead.</p>

<h3 id="where">WHERE</h3>
<p>The <code class="language-plaintext highlighter-rouge">WHERE</code> clause is used to filter the records and extract only the ones that meet a certain condition. This can be used for all <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, and <code class="language-plaintext highlighter-rouge">DELETE</code> statements.</p>

<p>Strings must be enclosed in single quotes, while numbers do not.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Jack'</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>You can also use multiple conditions using <code class="language-plaintext highlighter-rouge">AND</code> and <code class="language-plaintext highlighter-rouge">OR</code>.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'John'</span> <span class="k">AND</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'John'</span> <span class="k">AND</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">OR</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>

<p>These are the comparison operators that can be used with <code class="language-plaintext highlighter-rouge">WHERE</code>:</p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>=</td>
      <td>Equal</td>
    </tr>
    <tr>
      <td>&lt;&gt; or !=</td>
      <td>Not equal</td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td>Greater than</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>Greater than or equal to</td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td>Less than</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>Less than or equal to</td>
    </tr>
    <tr>
      <td>NOT</td>
      <td>negate a condition</td>
    </tr>
    <tr>
      <td>BETWEEN</td>
      <td>Between a range (inclusive)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></td>
    </tr>
    <tr>
      <td>IS NULL</td>
      <td>is NULL value</td>
    </tr>
    <tr>
      <td>NOT NULL</td>
      <td>is  non-NULL value</td>
    </tr>
    <tr>
      <td>IN()</td>
      <td>Matches a value inside the IN, mostly used to avoid using multiple OR conditions</td>
    </tr>
    <tr>
      <td>LIKE</td>
      <td>Pattern matching</td>
    </tr>
    <tr>
      <td>EXISTS()</td>
      <td>True if subquery returns at least one row</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h3 id="in">IN</h3>
<p>Mostly used to avoid using multiple <code class="language-plaintext highlighter-rouge">OR</code> conditions.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Jack'</span>
    <span class="k">OR</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'John'</span>
    <span class="k">OR</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Jane'</span><span class="p">;</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'Jack'</span><span class="p">,</span> <span class="s1">'John'</span><span class="p">,</span> <span class="s1">'Jane'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="like">LIKE</h3>
<p>This operator is used in a <code class="language-plaintext highlighter-rouge">WHERE</code> clause for pattern matching using the following wildcards:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">'%'</code>: represents any character of any length, including the length of zero</li>
  <li><code class="language-plaintext highlighter-rouge">'_'</code>: represents a single character</li>
</ul>

<p>Here are a few examples:</p>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Example matches</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'a%'</code></td>
      <td>apple, at, a, are</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'%s'</code></td>
      <td>cars, mats, bats, s</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'c_t'</code></td>
      <td>cat, cot, cut</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'_r%'</code></td>
      <td>arp, art, articulate, bracket</td>
    </tr>
  </tbody>
</table>

<p><em>Note: This also works with numbers. <code class="language-plaintext highlighter-rouge">WHERE num LIKE '32_'</code> will find 320, 321, 322, 323‚Ä¶</em></p>

<h3 id="exists">EXISTS</h3>
<p>As mentioned above, this operator is used with a subquery, where the condition is met if the subquery returns at least one row. A subquery is a select statement that is nested inside another query (more info below).</p>

<p>Say we have another table called ACCOUNTS.</p>

<table>
  <thead>
    <tr>
      <th>ACCOUNTS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CUSTOMER_ID<br />USERNAME<br />PASSWORD</td>
    </tr>
  </tbody>
</table>

<p>We can then query something like this:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">username</span> <span class="k">FROM</span> <span class="n">accounts</span>
  <span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
                <span class="k">WHERE</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">);</span>
</code></pre></div></div>
<p>And it will return all the usernames where it has matching customer_id in both tables.</p>

<p><em>Note:</em> The query above can be similarly achieved with an inner join, such as:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">username</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">c</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">accounts</span> <span class="n">a</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>

<p>The difference is that the one using <code class="language-plaintext highlighter-rouge">EXISTS</code> simply returns results from the CUSTOMERS table when the condition matches and the <code class="language-plaintext highlighter-rouge">INNER JOIN</code> combines two tables first and returns results from the combined table. Having duplicates can lead to having repeated rows if the inner join is used.</p>

<h3 id="subqueries">Subqueries</h3>
<p>Subqueries can be used inside <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">WHERE</code>, and <code class="language-plaintext highlighter-rouge">FROM</code> clauses.</p>

<p>It executes the inner subquery first and uses that result to perform the outer queries.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">username</span> <span class="k">FROM</span> <span class="n">accounts</span> <span class="n">a</span>
  <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span> <span class="k">IN</span>
    <span class="p">(</span><span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">customer_id</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">c</span>
      <span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>
<p>It first executes the subquery to obtain the results. Let‚Äôs say the customer id for those above the age of 20 turned out to be 1, 5, 7, and 30. Now the outer query will try to find records that have a match with these customer ids.</p>

<p>Note that there can be multiple nested subqueries. But there is a limit of 255 levels of subqueries for the <code class="language-plaintext highlighter-rouge">WHERE</code> clause, and no limit for the <code class="language-plaintext highlighter-rouge">FROM</code> clause. (This is for Oracle SQL)</p>

<h3 id="order-by">ORDER BY</h3>
<p>This is used to sort the results, and it can only be used with <code class="language-plaintext highlighter-rouge">SELECT</code> queries.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>

<p>It will order the results in ascending order by default even if you don‚Äôt use the <code class="language-plaintext highlighter-rouge">ASC</code> keyword. For descending order, use the keyword <code class="language-plaintext highlighter-rouge">DESC</code>.</p>

<p>You can also use multiple columns.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">age</span><span class="p">,</span> <span class="n">customer_id</span> <span class="k">DESC</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">age</span> <span class="k">ASC</span><span class="p">,</span>
  <span class="n">customer_id</span> <span class="k">DESC</span><span class="p">;</span> <span class="cm">/* This is also possible */</span>
</code></pre></div></div>

<p>This will simply use the following columns as the next sorting condition. So for the query above, if two rows have the same age, it will then sort by customer_id.</p>

<h3 id="group-by">GROUP BY</h3>
<p>This clause is used for grouping results based on matching values in specified columns, and usually in conjunction with an aggregate function (e.g. SUM, COUNT, MIN, MAX, AVG).</p>

<p>The syntax is as follows:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">,</span> <span class="p">...</span>
    <span class="n">agg_func1</span><span class="p">(</span><span class="n">agg_exp1</span><span class="p">),</span> <span class="n">agg_func2</span><span class="p">(</span><span class="n">agg_exp2</span><span class="p">),</span> <span class="p">...</span>
    <span class="p">[</span><span class="k">WHERE</span> <span class="n">conditions</span><span class="p">]</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">,</span> <span class="p">...;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">exp1, exp2, ...</code>: must be included in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause, and excluded from the aggregate functions</p>

<p>The reason why you don‚Äôt want the same columns in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> as in the aggregate functions is because it wouldn‚Äôt make sense to perform some aggregate function on the rows in which all the values are the same. If you‚Äôre grouping by ‚Äúage‚Äù, for example, and you try to get the max age value from a group of people with the same age, you‚Äôd just get the same value.</p>

<p>I guess the only aggregate function that would make sense would be <code class="language-plaintext highlighter-rouge">COUNT</code>, as that will return the count number for each group value.</p>

<p>Here‚Äôs an example.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">;</span> <span class="cm">/* this also works */</span>
<span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="n">customer_id</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">;</span> <span class="cm">/* this returns an error */</span>
</code></pre></div></div>

<p>You can also group by multiple columns. So if we group by both age and gender, it will return all the existing combinations of the two columns.
So for the example below:</p>

<table>
  <thead>
    <tr>
      <th>customer_id</th>
      <th>age</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>20</td>
      <td>M</td>
    </tr>
    <tr>
      <td>2</td>
      <td>20</td>
      <td>F</td>
    </tr>
    <tr>
      <td>3</td>
      <td>25</td>
      <td>M</td>
    </tr>
    <tr>
      <td>4</td>
      <td>25</td>
      <td>M</td>
    </tr>
  </tbody>
</table>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">as</span> <span class="k">count</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">,</span> <span class="n">gender</span><span class="p">;</span>
</code></pre></div></div>

<p>The result will be:</p>

<table>
  <thead>
    <tr>
      <th>age</th>
      <th>gender</th>
      <th>count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>M</td>
      <td>1</td>
    </tr>
    <tr>
      <td>20</td>
      <td>F</td>
      <td>1</td>
    </tr>
    <tr>
      <td>25</td>
      <td>M</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="join">JOIN</h3>

<h4 id="inner-join">Inner Join</h4>
<p>Inner join is probably the most common type of join you‚Äôll be using. It returns results in which the condition is met for both tables. If we look at them in a venn diagram, we‚Äôre talking about the middle overlapping area, where the two tables intersect.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">accounts</span><span class="p">.</span><span class="n">username</span>
  <span class="k">FROM</span> <span class="n">customers</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">accounts</span>
  <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>
<p>So only the rows that have matching customer ids in both tables will be returned. The keyword <code class="language-plaintext highlighter-rouge">INNER</code> is optional.</p>

<p>There‚Äôs another way to perform this inner join, using the older syntax.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">accounts</span><span class="p">.</span><span class="n">username</span>
  <span class="k">FROM</span> <span class="n">customer</span><span class="p">,</span> <span class="n">accounts</span>
  <span class="k">WHERE</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>
<p>But recognizing this as an inner join is not as obvious, so try to avoid this older syntax.</p>

<p>You can also use the <code class="language-plaintext highlighter-rouge">USING</code> instead of <code class="language-plaintext highlighter-rouge">ON</code>, but this is only true for <strong>equijoins</strong> (join conditions using an equality operator):</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">accounts</span><span class="p">.</span><span class="n">username</span>
  <span class="k">FROM</span> <span class="n">customers</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">accounts</span>
  <span class="k">USING</span> <span class="p">(</span><span class="n">customer_id</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="outer-join">Outer Join</h4>
<p>We have left outer join and right outer join. Left outer join will return all of the rows from the left table, and only those that match the join condition from the right table.
The opposite will be true for the right outer join.</p>

<p>This can result in some rows with null values.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">accounts</span><span class="p">.</span><span class="n">username</span>
 <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">accounts</span>
 <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>
<p>Use <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code> for right join.</p>

<p>Note that we can achieve right join using the <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> by simply switching the order of tables. So the following query is equivalent to the one above.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">accounts</span><span class="p">.</span><span class="n">username</span>
 <span class="k">FROM</span> <span class="n">accounts</span> <span class="k">RIGHT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">customers</span>
 <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>

<p>You can also perform join operations on multiple columns or conditions. <br />
<code class="language-plaintext highlighter-rouge">ON t1.col1 = t2.col2 AND t1.col2 = t2.col2 ...</code><br />
or<br />
<code class="language-plaintext highlighter-rouge">USING (col1, col2, ...)</code></p>

<p>There‚Äôs also a <strong>full outer join</strong>, or a full join, where you combine both tables, regardless of whether on not they have a match. So in terms of the venn diagram, we‚Äôre talking about the entire thing. The syntax is the same, but use the keyword <code class="language-plaintext highlighter-rouge">FULL JOIN</code> instead.</p>

<h3 id="insert">INSERT</h3>
<p>This statement is used to insert records into a table. The basic syntax is:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="p">...)</span>
  <span class="k">VALUES</span> <span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div>
<p>You can omit the comma-separated columns, but then you have to provide the values for all the columns in their respective orders. Not good practice. Also, certain values that have a default value or can be NULL can be omitted.</p>

<p>You can also use <code class="language-plaintext highlighter-rouge">SELECT</code> in conjunction with <code class="language-plaintext highlighter-rouge">INSERT</code> to insert multiple values into a table. This is especially useful for copying data into another table.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="p">...)</span>
  <span class="k">SELECT</span> <span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">,</span> <span class="p">...</span>
    <span class="k">FROM</span> <span class="n">source_table</span><span class="p">;</span>
</code></pre></div></div>
<p>This will copy the values obtained from <code class="language-plaintext highlighter-rouge">exp1</code> and <code class="language-plaintext highlighter-rouge">exp2</code> into <code class="language-plaintext highlighter-rouge">col1</code> and <code class="language-plaintext highlighter-rouge">col2</code>, respectively. You can use literals instead of columns for the <code class="language-plaintext highlighter-rouge">exp</code> to set a constant value.</p>

<p>So let‚Äôs say <code class="language-plaintext highlighter-rouge">col2</code> takes in a number, and instead of <code class="language-plaintext highlighter-rouge">exp2</code>, we input the value <code class="language-plaintext highlighter-rouge">0</code>. Then all the rows will have the value 0 for <code class="language-plaintext highlighter-rouge">col2</code>.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">exp1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">FROM</span> <span class="n">source_table</span><span class="p">;</span>
</code></pre></div></div>

<p>For inserting multiple rows into one or multiple tables using a single statement, use the following syntax:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">ALL</span>
  <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">col11</span><span class="p">,</span> <span class="n">col12</span><span class="p">,</span> <span class="p">...)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="n">val11</span><span class="p">,</span> <span class="n">val12</span><span class="p">,</span> <span class="p">...)</span>
  <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">col21</span><span class="p">,</span> <span class="n">col22</span><span class="p">,</span> <span class="p">...)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="n">val21</span><span class="p">,</span> <span class="n">val22</span><span class="p">,</span> <span class="p">...)</span>
  <span class="k">INTO</span> <span class="n">table_name2</span> <span class="p">(</span><span class="n">col31</span><span class="p">,</span> <span class="n">col32</span><span class="p">,</span> <span class="p">...)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="n">val31</span><span class="p">,</span> <span class="n">val32</span><span class="p">,</span> <span class="p">...)</span>
  <span class="p">[</span><span class="n">subquery</span><span class="p">];</span>
</code></pre></div></div>
<p>This is the same as using 3 separate <code class="language-plaintext highlighter-rouge">INSERT INTO</code> statements.</p>

<p>Notice that this statement requires a subquery. The values from <code class="language-plaintext highlighter-rouge">val11</code>, <code class="language-plaintext highlighter-rouge">val12</code>, <code class="language-plaintext highlighter-rouge">val21</code>, ‚Ä¶ must correspond to the values obtained from the subquery. If you want to use the values stated in <code class="language-plaintext highlighter-rouge">val11</code>, <code class="language-plaintext highlighter-rouge">val12</code>, <code class="language-plaintext highlighter-rouge">val21</code>, ‚Ä¶ as the literal values, then simply use <code class="language-plaintext highlighter-rouge">SELECT * FROM dual</code> for the subquery.</p>

<p>For instance, say we have two new tables, called USERS1 and USERS2, with only 2 columns, <code class="language-plaintext highlighter-rouge">FIRST_NAME</code> and <code class="language-plaintext highlighter-rouge">LAST_NAME</code>. We have another table, CUSTOMERS, with all the user information and we want to copy them into these two new tables. We can do the following.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">ALL</span>
  <span class="k">INTO</span> <span class="n">users1</span> <span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="n">user_first_name</span><span class="p">,</span> <span class="n">user_last_name</span><span class="p">)</span>
  <span class="k">INTO</span> <span class="n">users2</span> <span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="n">user_first_name</span><span class="p">,</span> <span class="n">user_last_name</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">user_first_name</span><span class="p">,</span> <span class="n">user_last_name</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
</code></pre></div></div>
<p>But say we only want to insert using the values themselves, without a subquery.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT ALL
  INTO users1 (first_name, last_name) values ('Elon', 'Musk')
  INTO users2 (first_name, last_name) values ('Jack', 'Ma')
  SELECT * FROM dual;
</code></pre></div></div>

<p>What is a dual table, you ask?</p>
<blockquote>
  <p>DUAL is a small table in the data dictionary that Oracle Database and user-written programs can reference to guarantee a known result. The dual table is useful when a value must be returned only once, for example, the current date and time. All database users have access to DUAL.</p>
</blockquote>

<p>You can think of it as a dummy query for this case.</p>

<p>You can find more info <a href="https://docs.oracle.com/cd/E11882_01/server.112/e40540/datadict.htm#CNCPT1210">here</a> or check out this <a href="https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:1562813956388">post</a>.</p>

<p><strong>Important</strong>: Remember to use <code class="language-plaintext highlighter-rouge">commit;</code> after inserting all the rows to make the changes permanent.</p>

<h3 id="update">UPDATE</h3>
<p>Use this statement to update existing records in a table.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="k">table_name</span>
  <span class="k">SET</span>
    <span class="n">col1</span> <span class="o">=</span> <span class="n">val1</span><span class="p">,</span>
    <span class="n">col2</span> <span class="o">=</span> <span class="n">val2</span><span class="p">,</span>
    <span class="p">...</span>
  <span class="k">WHERE</span> <span class="n">condition</span><span class="p">;</span>
</code></pre></div></div>
<p>So we could do something like this:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">customers</span>
  <span class="k">SET</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">30</span>
  <span class="k">WHERE</span> <span class="n">customer_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>If multiple tables are used without any join operations, it will simply do a cross join (or a <a href="https://en.wikipedia.org/wiki/Cartesian_product">cartesian product</a>) to create all possible combinations. This is rarely used, so if you get this type of join, there is probably some syntax error.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">WHERE age BETWEEN 20 and 30</code> is equal to <code class="language-plaintext highlighter-rouge">WHERE age &gt;= 20 AND age &lt;= 30</code>¬†<a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET
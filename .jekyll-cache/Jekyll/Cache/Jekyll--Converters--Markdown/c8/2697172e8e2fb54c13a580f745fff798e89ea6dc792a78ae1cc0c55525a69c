I"ÆM<h3 id="select">SELECT</h3>

<p>Let‚Äôs say this is our table.</p>

<table>
  <thead>
    <tr>
      <th>CUSTOMERS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CUSTOMER_ID<br />FIRST_NAME<br />LAST_NAME<br />BIRTHDAY<br />ADDRESS<br />AGE</td>
    </tr>
  </tbody>
</table>

<p>The basic format is:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">exp</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="p">[</span><span class="k">WHERE</span> <span class="n">condition</span><span class="p">];</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">exp</code>: use * for selecting all columns, or list the specific columns you want<br />
<code class="language-plaintext highlighter-rouge">table_name</code>: at least one table required<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><br />
<code class="language-plaintext highlighter-rouge">condition</code>: returns all rows if no condition is used</p>

<p>ex)</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">;</span>
</code></pre></div></div>

<p>If you want to return only distinct values, you can use <code class="language-plaintext highlighter-rouge">SELECT DISTINCT</code> instead.</p>

<h3 id="where">WHERE</h3>
<p>The <code class="language-plaintext highlighter-rouge">WHERE</code> clause is used to filter the records and extract only the ones that meet a certain condition. This can be used for all <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, and <code class="language-plaintext highlighter-rouge">DELETE</code> statements.</p>

<p>Strings must be enclosed in single quotes, while numbers do not.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Jack'</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>You can also use multiple conditions using <code class="language-plaintext highlighter-rouge">AND</code> and <code class="language-plaintext highlighter-rouge">OR</code>.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'John'</span> <span class="k">AND</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'John'</span> <span class="k">AND</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">OR</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>

<p>These are the comparison operators that can be used with <code class="language-plaintext highlighter-rouge">WHERE</code>:</p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>=</td>
      <td>Equal</td>
    </tr>
    <tr>
      <td>&lt;&gt; or !=</td>
      <td>Not equal</td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td>Greater than</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>Greater than or equal to</td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td>Less than</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>Less than or equal to</td>
    </tr>
    <tr>
      <td>NOT</td>
      <td>negate a condition</td>
    </tr>
    <tr>
      <td>BETWEEN</td>
      <td>Between a range (inclusive)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></td>
    </tr>
    <tr>
      <td>IS NULL</td>
      <td>is NULL value</td>
    </tr>
    <tr>
      <td>NOT NULL</td>
      <td>is  non-NULL value</td>
    </tr>
    <tr>
      <td>IN()</td>
      <td>Matches a value inside the IN, mostly used to avoid using multiple OR conditions</td>
    </tr>
    <tr>
      <td>LIKE</td>
      <td>Pattern matching</td>
    </tr>
    <tr>
      <td>EXISTS()</td>
      <td>True if subquery returns at least one row</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h3 id="in">IN</h3>
<p>Mostly used to avoid using multiple <code class="language-plaintext highlighter-rouge">OR</code> conditions.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Jack'</span>
    <span class="k">OR</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'John'</span>
    <span class="k">OR</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Jane'</span><span class="p">;</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">WHERE</span> <span class="n">first_name</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'Jack'</span><span class="p">,</span> <span class="s1">'John'</span><span class="p">,</span> <span class="s1">'Jane'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="like">LIKE</h3>
<p>This operator is used in a <code class="language-plaintext highlighter-rouge">WHERE</code> clause for pattern matching using the following wildcards:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">'%'</code>: represents any character of any length, including the length of zero</li>
  <li><code class="language-plaintext highlighter-rouge">'_'</code>: represents a single character</li>
</ul>

<p>Here are a few examples:</p>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Example matches</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'a%'</code></td>
      <td>apple, at, a, are</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'%s'</code></td>
      <td>cars, mats, bats, s</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'c_t'</code></td>
      <td>cat, cot, cut</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'_r%'</code></td>
      <td>arp, art, articulate, bracket</td>
    </tr>
  </tbody>
</table>

<p><em>Note: This also works with numbers. <code class="language-plaintext highlighter-rouge">WHERE num LIKE '32_'</code> will find 320, 321, 322, 323‚Ä¶</em></p>

<h3 id="exists">EXISTS</h3>
<p>As mentioned above, this operator is used with a subquery, where the condition is if the subquery returns at least one row. A subquery is a select statement that is nested inside another query (more info below).</p>

<p>Say we have another table called ACCOUNTS.</p>

<table>
  <thead>
    <tr>
      <th>ACCOUNTS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CUSTOMER_ID<br />USERNAME<br />PASSWORD</td>
    </tr>
  </tbody>
</table>

<p>We can then query something like this:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">username</span> <span class="k">FROM</span> <span class="n">accounts</span>
  <span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span>
                <span class="k">WHERE</span> <span class="n">customers</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">accounts</span><span class="p">.</span><span class="n">customer_id</span><span class="p">);</span>
</code></pre></div></div>
<p>And it will return all the usernames where it has matching customer_id in both tables.</p>

<p><em>Note:</em> The query above can be similarly achieved with an inner join, such as:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">username</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">c</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">accounts</span> <span class="n">a</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>

<p>The difference is that the one using <code class="language-plaintext highlighter-rouge">EXISTS</code> simply returns results from the CUSTOMERS table when the condition matches, and the <code class="language-plaintext highlighter-rouge">INNER JOIN</code> combines two tables first and returns results from the combined table. Having duplicates can lead to having repeated rows if the inner join is used.</p>

<h3 id="subqueries">Subqueries</h3>
<p>Subqueries can be used inside <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">WHERE</code>, and <code class="language-plaintext highlighter-rouge">FROM</code> clauses.</p>

<p>It executes the inner subquery first and uses that result to perform the outer queries.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">username</span> <span class="k">FROM</span> <span class="n">accounts</span> <span class="n">a</span>
  <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span> <span class="k">IN</span>
    <span class="p">(</span><span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">customer_id</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">c</span>
      <span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>
<p>It first executes the subquery to obtain the results. Let‚Äôs say the customer id for those above the age of 20 turned out to be 1, 5, 7, and 30. Now the outer query will try to find records that have a match with these customer ids.</p>

<p>Note that there can be multiple nested subqueries. But there is a limit of 255 levels of subqueries for the <code class="language-plaintext highlighter-rouge">WHERE</code> clause, and no limit for the <code class="language-plaintext highlighter-rouge">FROM</code> clause. (This is for Oracle SQL)</p>

<h3 id="order-by">ORDER BY</h3>
<p>This is used to sort the results, and it can only be used with <code class="language-plaintext highlighter-rouge">SELECT</code> queries.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customer_id</span><span class="p">;</span>
</code></pre></div></div>

<p>It will order the results in ascending order by default even if you don‚Äôt use the <code class="language-plaintext highlighter-rouge">ASC</code> keyword. For descending order, use the keyword <code class="language-plaintext highlighter-rouge">DESC</code>.</p>

<p>You can also use multiple columns.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">age</span><span class="p">,</span> <span class="n">customer_id</span> <span class="k">DESC</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">age</span> <span class="k">ASC</span><span class="p">,</span>
  <span class="n">customer_id</span> <span class="k">DESC</span><span class="p">;</span> <span class="cm">/* This is also possible */</span>
</code></pre></div></div>

<p>This will simply use the following columns as the next sorting condition. So for the query above, if two rows have the same age, it will then sort by customer_id.</p>

<h3 id="group-by">GROUP BY</h3>
<p>This clause is used for grouping results based on matching values in specified columns, and usually in conjunction with an aggregate function (e.g. SUM, COUNT, MIN, MAX, AVG).</p>

<p>The syntax is as follows:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">,</span> <span class="p">...</span>
    <span class="n">agg_func1</span><span class="p">(</span><span class="n">agg_exp1</span><span class="p">),</span> <span class="n">agg_func2</span><span class="p">(</span><span class="n">agg_exp2</span><span class="p">),</span> <span class="p">...</span>
    <span class="p">[</span><span class="k">WHERE</span> <span class="n">conditions</span><span class="p">]</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">,</span> <span class="p">...;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">exp1, exp2, ...</code>: must be included in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause, and excluded from the aggregate functions</p>

<p>The reason why you don‚Äôt want the same columns in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> as in the aggregate functions is because it wouldn‚Äôt make sense to perform some aggregate function on the rows in which all the values are the same. If you‚Äôre grouping by ‚Äúage‚Äù, for example, and you try to get the max age value from a group of people with the same age, you‚Äôd just get the same value.</p>

<p>I guess the only aggregate function that would make sense would be <code class="language-plaintext highlighter-rouge">COUNT</code>, as that will return the count number for each group value.</p>

<p>Here‚Äôs an example.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">;</span> <span class="cm">/* this also works */</span>
<span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="n">customer_id</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">;</span> <span class="cm">/* this returns an error */</span>
</code></pre></div></div>

<p>You can also group by multiple columns. So if we group by both age and gender, it will return all the existing combinations of the two columns.
So for the example below:</p>

<table>
  <thead>
    <tr>
      <th>customer_id</th>
      <th>age</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>20</td>
      <td>M</td>
    </tr>
    <tr>
      <td>2</td>
      <td>20</td>
      <td>F</td>
    </tr>
    <tr>
      <td>3</td>
      <td>25</td>
      <td>M</td>
    </tr>
    <tr>
      <td>4</td>
      <td>25</td>
      <td>M</td>
    </tr>
  </tbody>
</table>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">age</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span> <span class="k">as</span> <span class="k">count</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">age</span><span class="p">,</span> <span class="n">gender</span><span class="p">;</span>
</code></pre></div></div>

<p>The result will be</p>

<table>
  <thead>
    <tr>
      <th>age</th>
      <th>gender</th>
      <th>count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>M</td>
      <td>1</td>
    </tr>
    <tr>
      <td>20</td>
      <td>F</td>
      <td>1</td>
    </tr>
    <tr>
      <td>25</td>
      <td>M</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
<h3 id="join">JOIN</h3>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>If multiple tables are used without any join operations, it will simply do a cross join (or a <a href="https://en.wikipedia.org/wiki/Cartesian_product">cartesian product</a>) to create all possible combinations.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">WHERE age BETWEEN 20 and 30</code> is equal to <code class="language-plaintext highlighter-rouge">WHERE age &gt;= 20 AND age &lt;= 30</code>¬†<a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET